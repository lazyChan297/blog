# TCP&UDP
两者都是作用于TCP/IP四层模型中的传输层协议

## TCP
传输控制协议，一种面向连接的、可靠的、基于字节流的传输层通信协议

### 标志码说明
- SYN: 发起连接报文，发起握手的那一方会携带这个标志码，如果是第一次`SYN=1`
- ACK: 确认回应，回应发起握手那一方携带的标志位，如果是第一次，ACK=1
- FIN: 断开链接报文
- seq: 随机序列号
- ack: 确认序列号，以对方传递的seq值为基准加1，是tcp数据可靠传输的基础

### 三次握手过程
建立连接前，tcp协议会发起三次握手，确认通信双方的接收能力
**第一次握手**
- 发送`SYN = 1`报文，表示第一次发起
- 发送初始化的序列号`seq` 为了标识是客户端哪一个应用程序发起的

**第二次握手，服务端发起**<br/>
- **SYN=1**表示服务端第一次发起，证明了服务端的发送能力
- **ACK=1**表示服务端第一次应答，证明了服务端的接受能力
- **ack=客户端初始化序列号+1**，为了确认客户端发送的SYN，把客户端发送的seq+1返回 （个人理解为这一标志为是确认对方的端口号，因为一台主机可以有多个客户端向服务器发起握手请求，ack是为确认来自哪个端口，表示服务端收到了客户端发起链接的某一个应用程序）
- **seq=服务端初始化序列号**，表示服务端的序列号，标识客户端某一个端口作出响应

**第三次握手，客户端发起**
- `ACK = 1` 客户端收到ACK=1知道了发起建立连接的服务器已经应答，所以客户端发送ACK，告知服务器它发来的建立联机已经确认，证明了客户端的接收能力
- `ack = 服务端seq + 1` 为了确认收到了服务端发来的SYN，把服务端seq+1返回
- `seq = 客户端seq + 1` 告知服务端，仍然是第一次发起握手请求的客户端发来的确认信息，因为是第二次发送，所以需要seq + 1

**只需要三次握手的原因** 三次就可以确认双方的收发能力正常，所以三次足矣
- 第一次握手，确认了客户端发送能力
- 第二次握手，确认了服务端发送、接受能力
- 第三次握手，确认了客户端发送能力

### 四次挥手过程
断开连接前tcp链接会触发四次挥手
**第一次挥手，客户端发起**
- 发送`FIN = 1`，告知服务器断开链接
- 发送`seq = x`，告知服务器是来自客户端的哪一个端口

**第二次挥手，服务端发起**
- 发送`ACK = 1`，告知客服端已经收到断开链接的请求
- 发送`ack = 客户端seq + 1`，告知客户的确认来自哪一个客户端端口
- 发送`seq = y`，告知客户端是服务器哪一个端口断开链接

**第三次挥手，服务器发起**
- 发送`FIN = 1`，告知客户端内容全部发送完成，发起断开链接的请求
- 发送`ack = 客户端seq + 1`，个人理解，再一次发送`ack`目的是让客户端确认还是刚刚服务器发送的确认断开连接
- 发送`seq = j`，告知客户端是服务器哪一个端口断开链接
- 发送`ACK = 1`，告知客服端已经收到断开链接的请求

**第四次挥手，客户端发起**
- 发送`ACK = 1`，告知服务器已经收到断开链接的请求
- 发送`seq = 客户端seq + 1`，告知服务器仍然是第一次发起断开链接的客户端端口应答，确认收到了断开链接的请求
- `ack = 服务器seq + 1`，告知服务器，已经收到断开连接的请求了，可以断开了

**需要四次挥手的原因**
因为当服务器收到客户端的`FIN`报文时，服务器很可能还有内容没有传输完毕，<br/>
所以需要等服务器再一次发次`FIN`（第三次挥手），<br/>
客户端的应答（第四次）。<br/>
本质上和三次握手确认双方的收发能力正常外，还需要一次是确认双方都发送了`FIN`

### 重传机制
为了保证TCP传输的数据都可以到达

#### 超时重传
发送方发送seq时会开启一个定时器，如果超时没有收到对应的`ack`，那么会启用超时重传，也可能会把后续的数据包一起重传。但是这样会使等待的时间过长，也可能会造成带宽的浪费

#### 快速重传
假如发送方连续发送5个数据包给接收方，数据包2因为某些原因延迟，但是3、4、5陆续到达了。所以接收方发送了三个ack=2的确认应答给发送方。发送方则根据ack得知是数据包2超时，所以启用快速重传。假如数据包出现连续的延迟或丢失，接收方发送了ack=2，ack=9，ack=15，那么此时可能会把2-15的数据包一起重传

#### SACK
为了解决重复数据的问题，接受方在原有的ack基础上增加了SACK，表示本次实际接收到的seq，这样发送方就可以精准的知道是哪个包丢失了

### 滑动窗口
作用是为了防止网络拥堵导致数据丢包，也是tcp保证数据可靠传输的支撑之一<br/>
接收方每次应答的时候会携带`Advertised-Window`的值，告知发送方自己还剩余多少缓存区可用；发送方接收到该值后会调整数据包的大小再发送
#### zero window
发送方每次发送的`Advertised-Window`值都是递减的，当发送端接收到的值变为0的时候，发送方会把ZeroWindowProbe的包发给接收方，让接收方应答它可用的window大小，一般这个值会设置三次，每次等待`30-60`s，如果三次过后仍然为0，那么连接很可能会断开
#### silly window
- 接收方造成拥堵时，会应答ack=0给发送方，关闭接受的窗口，直到window size大于mss=578(每一个ip设备至少接受的size)时才会重新打开窗口
- 发送方造成拥堵时
    1. 当window size >= mss 或者 要发送的数据>= mss 时 
    2. 当收到接受方的ack回执

### 拥塞处理
TCP协议拥有以下一系列的拥塞控制机制，防止网络拥堵导致数据丢包
#### 慢启动
最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免拥塞现象的发生。
**当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。**

#### 拥塞避免
当拥塞窗口`cwnd`的值达到慢启动门限阈值（ssthresh）时，就会进入拥塞避免状态，此时`cwnd`不再是指数级增加，而是加法增加，这样可以防止发送的数据包过大而超出接收方的接收范围<br/>
当发生快速重传的时候，TCP也会作出以下操作，判定网络进入拥塞避免状态，同时作出以下调整
- 慢启动门限阈值（ssthresh）降低为拥塞窗口（cwnd）的一半
- 拥塞窗口（cwnd）设置为慢启动门限阈值（ssthresh）
- 进入拥塞避免状态
#### 拥塞状态
当出现超时重传，TCP认为网络进入了`拥塞状态`，TCP就会作出以下调整
- 将慢启动门限阈值（ssthresh）降低为拥塞窗口（cwnd）的一半
- 将拥塞窗口（cwnd）重新设置为1
- 此时网络就会重新进入慢启动状态

#### 快速恢复
当之前丢失的包都收到ack应答时，证明丢失的数据包接收方都已经收到，此时启用快速恢复机制，使网络进入拥塞避免状态


## UDP
用户数据包协议，是一个简单的「面向数据报的通信协议」，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层

## TCP/UDP之间的区别
- TCP是面向连接的，建立连接前发起三次握手，断开连接前发起四次挥手，通过握手和挥手的过程中通过SYN报文，FIN报文和序列号确认了双方是自己的通信目标，而UDP是面向无连接的。
- TCP连接传输的数据更可靠，可靠体现在避免数据丢失、超时、重复，保证数据按序到达，以上措施是序列号和确认应答码机制来实现的。
    - 数据丢失或延迟，发送方发送seq时会开启一个定时器，如果在指定时间内没有接收到ACK（seq + 1），那么会把数据和seq再发送一次
- UDP传输效率比TCP快
- TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用
- TCP支持全双工通信（双向同时通信），UDP支持1对1，一对多，多对多，多对一
- TCP 应用场景适用于对效率要求低，对准确性要求高或者要求有链接的场景，而UDP 适用场景为对效率要求高，对准确性要求低的场景

## 参考
1. [TCP 的那些事儿（上）](https://coolshell.cn/articles/11564.html)
2. [TCP 的那些事儿（下）](https://coolshell.cn/articles/11609.html)