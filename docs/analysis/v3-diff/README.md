# v3的diff算法

**前后置处理，找到相同的前置和后置元素**
定义一枚头指针和新旧子节点列表的两枚尾指针。头指针向后移动，尾指针向前移动，如果指向的节点key相同则对比两个节点同时移动指针，直到头指针和其中一枚尾指针相遇

**指针相遇后会出现以下三种情况之一**

1. **节点新增** 头指针大于等于旧列表的尾指针小于新列表的尾指针，新增的节点是从头指针到新列表的尾指针

2. **节点删除** 头指针大于等于新列表的尾指针小于旧列表的尾指针，删除的节点是从头指针到旧列表的尾指针

3. **列表长度不变，需要逐一对比** 
    1. 根据当前头指针到新列表的尾指针的长度，可以得知剩余的没有对比过的新列表节点长度，根据这个长度，构建一个`source`数组，默认值是`-1`
    2. 同时根据没有对比过的新列表节点的key和在列表中的索引创建一个`map`对象，数据结构是`节点key: 索引值`
    3. 遍历旧列表没有对比过的节点，根据节点的key到`map`对象中查找是否寻找新列表中
        - 节点不存在则删除该节点
        - 节点存在，在`source`数组的第`[节点在新列表的索引位置-新列表的头指针]`位置上赋值`节点在旧列表的索引值`
    4. 找出`source`数组中最长递增子序列就可以清楚知道哪一段节点相对位置没有改变，这样便可以减少节点移动的次数
    5. 根据`节点在新列表的索引位置`是否大于`新列表中已经对比过节点的位置`**判断节点是否需要移动**
        - 小于，节点移动了
        - 大于，更新`新列表中已经对比过节点的位置`的值
    6. **节点移动**，遍历`新列表中没有对比过的节点`，如果索引值和`source`数组中的最长递增子序列的索引值判断是否相等
        - **新增节点**，判断是否移动前看查看`source`数组中对应的索引位置的值是否是`-1`，如果是说明该节点是新增的
        - 不相等，找到当前`新列表`遍历的索引值+`新列表头指针`的位置，将节点移动到该位置
        - 相等，节点不需要移动